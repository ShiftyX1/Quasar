# Архитектура фронтенда Quasar Chat

## Обзор архитектуры

Фронтенд Quasar Chat построен на основе современных принципов разработки React-приложений с использованием Next.js. Архитектура основана на следующих ключевых принципах:

1. **Компонентный подход** - UI разбит на переиспользуемые компоненты
2. **Контекстное управление состоянием** - использование React Context API для глобального состояния
3. **Типизация кода** - использование TypeScript для повышения надежности кода
4. **Декларативные формы** - использование React Hook Form и Zod
5. **Клиент-серверная архитектура** - взаимодействие с бэкендом через REST API и WebSockets

## Архитектурные слои

Архитектура фронтенда разделена на следующие слои:

### 1. Слой представления (Presentation Layer)

Компоненты, отвечающие за отображение UI. Включает:

- **Компоненты страниц** (`src/app/`) - основные маршруты приложения
- **UI компоненты** (`src/components/`) - переиспользуемые компоненты интерфейса

### 2. Слой управления состоянием (State Management Layer)

Управление глобальным состоянием приложения:

- **Контексты** (`src/context/`) - React Context провайдеры для глобального состояния
- **Хуки** (`src/hooks/`) - кастомные React хуки для управления состоянием и логикой

### 3. Слой доступа к данным (Data Access Layer)

Взаимодействие с внешними источниками данных:

- **API клиенты** (`src/api/`) - функции для взаимодействия с бэкендом
- **WebSocket клиент** (`src/lib/socket.ts`) - клиент для обмена сообщениями в реальном времени

## Поток данных

### Аутентификация

1. Пользователь вводит данные в форму входа или регистрации
2. Form Handler собирает и валидирует данные с помощью React Hook Form и Zod
3. Данные передаются в контекст аутентификации через методы `login` или `register`
4. Контекст аутентификации вызывает соответствующие методы API
5. При успешном ответе от API, контекст обновляет состояние пользователя
6. Компоненты, использующие хук `useAuth`, реагируют на изменение состояния и перерисовываются

```
Пользователь -> Form Handler -> AuthContext -> API -> Бэкенд
                                      |
                                      v
                        Компоненты <- useAuth
```

### Работа с комнатами

1. При загрузке приложения контекст комнат запрашивает список комнат пользователя через API
2. Компоненты, использующие хук `useRooms`, получают доступ к списку комнат
3. При создании или присоединении к комнате вызываются соответствующие методы API
4. После успешного ответа от API, контекст обновляет список комнат
5. Компоненты, использующие данные комнат, автоматически обновляются

```
API -> RoomContext -> useRooms -> Компоненты
 ^         |
 |         v
 --------- Действия пользователя
```

### Обмен сообщениями

1. При открытии комнаты компонент `ChatRoom` загружает историю сообщений через API
2. Одновременно компонент подключается к WebSocket и подписывается на события комнаты
3. При отправке сообщения данные передаются через API и WebSocket
4. При получении нового сообщения через WebSocket, компонент обновляет список сообщений
5. Список сообщений автоматически прокручивается к последнему сообщению

```
                 +--> API ---------------+
                 |                       v
Пользователь -> ChatRoom -> MessageList -> MessageItem
                 |    ^
                 v    |
               WebSocket
```

## Контексты и их взаимодействие

### AuthContext

Контекст аутентификации предоставляет информацию о текущем пользователе и методы для авторизации:

```typescript
interface AuthContextType {
  user: User | null;         // Текущий пользователь
  loading: boolean;          // Загрузка аутентификации
  login: (data: LoginParams) => Promise<void>;     // Метод входа
  register: (data: RegisterParams) => Promise<void>; // Метод регистрации
  logout: () => Promise<void>;   // Метод выхода
  error: string | null;      // Ошибка аутентификации
}
```

### RoomContext

Контекст комнат зависит от контекста аутентификации и предоставляет информацию о комнатах пользователя:

```typescript
interface RoomContextType {
  userRooms: Room[];         // Список комнат пользователя
  loading: boolean;          // Загрузка комнат
  error: string | null;      // Ошибка загрузки комнат
  refreshRooms: () => Promise<void>;  // Метод обновления списка комнат
  clearRooms: () => void;    // Метод очистки списка комнат
}
```

Взаимодействие контекстов:
- `RoomContext` использует состояние пользователя из `AuthContext` для загрузки комнат
- `RoomContext` очищает список комнат при выходе пользователя

## Маршрутизация

Маршрутизация в приложении построена на основе файловой системы Next.js:

```
src/app/
  ├── page.tsx                # Главная страница (/)
  ├── layout.tsx              # Общий layout для всех страниц
  ├── auth/
  │   ├── login/
  │   │   └── page.tsx        # Страница входа (/auth/login)
  │   └── register/
  │       └── page.tsx        # Страница регистрации (/auth/register)
  └── rooms/
      ├── create/
      │   └── page.tsx        # Создание комнаты (/rooms/create)
      ├── join/
      │   └── page.tsx        # Присоединение к комнате (/rooms/join)
      └── [id]/
          └── page.tsx        # Страница комнаты (/rooms/[id])
```

## Стилизация

Стилизация в Quasar Chat основана на комбинации Tailwind CSS и компонентов Ant Design:

- **Tailwind CSS** используется для базовой стилизации и кастомных компонентов
- **Ant Design** предоставляет готовые UI компоненты (формы, кнопки, таблицы и т.д.)
- **CSS Modules** используются при необходимости для изолированных стилей компонентов

## Управление зависимостями

Управление зависимостями осуществляется с помощью npm и package.json:

```json
{
  "dependencies": {
    "next": "^14.0.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "antd": "^5.0.0",
    "socket.io-client": "^4.0.0",
    "axios": "^1.0.0",
    "react-hook-form": "^7.0.0",
    "zod": "^3.0.0"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "tailwindcss": "^3.0.0",
    "postcss": "^8.0.0",
    "autoprefixer": "^10.0.0"
  }
}
```

## Архитектурные решения и обоснования

### Выбор React Context вместо Redux

Для управления состоянием используется React Context API вместо Redux по следующим причинам:
- Простота внедрения и использования
- Отсутствие необходимости в сложном глобальном состоянии
- Достаточная производительность для нашего приложения
- Более легкое понимание для новых разработчиков

### Выбор Next.js

Next.js был выбран по следующим причинам:
- Файловая маршрутизация упрощает организацию страниц
- Встроенная оптимизация производительности
- Возможность серверного рендеринга для SEO (при необходимости)
- Дополнительные возможности (API роуты, статическая генерация)

### Выбор Tailwind CSS

Tailwind CSS был выбран по следующим причинам:
- Ускорение разработки благодаря utility-first подходу
- Консистентная система дизайна
- Хорошая интеграция с React и Next.js
- Более низкий объем CSS в продакшн-сборке

## Рекомендации по расширению

### Добавление новой страницы

1. Создать файл `page.tsx` в соответствующей директории в `src/app/`
2. Реализовать компонент страницы с использованием существующих компонентов
3. При необходимости добавить layout в файл `layout.tsx`

### Добавление нового контекста

1. Создать файл контекста в директории `src/context/`
2. Определить типы данных и методы контекста
3. Реализовать провайдер контекста с использованием `useState` и `useEffect`
4. Создать хук для доступа к контексту в директории `src/hooks/`
5. Добавить провайдер в дерево компонентов (обычно в `src/app/layout.tsx`)

### Добавление новой функциональности WebSocket

1. Обновить клиент WebSocket в `src/lib/socket.ts`
2. Добавить обработчики событий в соответствующие компоненты
3. Реализовать отправку событий через WebSocket при необходимых действиях пользователя

## Тестирование

Для тестирования компонентов и логики рекомендуется использовать:

- **Jest** - для юнит-тестирования
- **React Testing Library** - для тестирования компонентов
- **Cypress** - для e2e тестирования

Пример структуры тестов:

```
src/
  __tests__/
    components/
      auth/
        LoginForm.test.tsx
      chat/
        MessageItem.test.tsx
    hooks/
      useAuth.test.ts
    api/
      auth.test.ts
```

## Заключение

Архитектура фронтенда Quasar Chat разработана с учетом современных практик и позволяет:
- Поддерживать чистый и понятный код
- Легко расширять функциональность
- Поддерживать типизацию для уменьшения ошибок
- Эффективно обновлять UI при изменении данных
- Обеспечивать удобный пользовательский опыт 